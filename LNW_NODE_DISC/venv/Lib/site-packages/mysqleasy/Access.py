##################################################################################
#
#  Â© 2016 Farukh Tamboli. All Rights Reserved.
#
# NOTICE:  All information contained herein is, and remains the property of
# Farukh Tamboli. The intellectual and technical concepts contained herein are
# proprietary to Farukh Tamboli and may be covered by U.S. and Foreign Patents,
# patents in process, and are protected by trade secret or copyright law.
# Dissemination of this information or reproduction of this material is strictly
# forbidden unless prior written permission is obtained from Farukh Tamboli.
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#
##################################################################################


from mysql.connector import Error
from . import ObjectDict


class Access(object):
    @staticmethod
    def search(conn, query, chunk_size, **kwargs):
        try:
            cursor = conn.cursor(buffered=True)
            filter_by = []
            args = ()
            if kwargs is not None:
                for key, value in kwargs.items():
                    args = args + (value,)
                    if isinstance(value, str) and "%" in value:
                        filter_by.append("%s like " % (key) + " %s")
                    else:
                        filter_by.append("%s = " % (key) + " %s")
            if len(filter_by) > 0:
                query += " where " + " and ".join(filter_by)
            cursor.execute(query, args)
            desc = cursor.description
            if chunk_size == 0:
                return desc, cursor.fetchall()
            elif chunk_size == 1:
                return desc, Access.iter_row_one(cursor)
            else:
                return desc, Access.iter_row_many(cursor, chunk_size)
        except Error as e:
            print(e)
            raise
        finally:
            if chunk_size == 0:
                cursor.close()
    @staticmethod
    def insert_one(conn, query, args):
        try:
            cursor = conn.cursor(prepared=True)
            cursor.execute(query, args)
            return cursor.lastrowid
        except Error as e:
            print(e)
            raise
        finally:
            # closing database connection.
            if conn.is_connected():
                cursor.close()
    @staticmethod
    def insert_many(conn, query, args):
        try:
            cursor = conn.cursor(prepared=True)
            cursor.executemany(query, args)
            return cursor.lastrowid, cursor.rowcount
        except Error as e:
            print(e)
            raise
        finally:
            # closing database connection.
            if conn.is_connected():
                cursor.close()
    @staticmethod
    def update_one(conn, query, args):
        try:
            cursor = conn.cursor(prepared=True)
            cursor.execute(query, args)
        except Error as e:
            print(e)
            raise
        finally:
            # closing database connection.
            if conn.is_connected():
                cursor.close()
    @staticmethod
    def update_many(conn, query, args):
        try:
            cursor = conn.cursor(prepared=True)
            cursor.executemany(query, args)
        except Error as e:
            print(e)
            raise
        finally:
            # closing database connection.
            if conn.is_connected():
                cursor.close()
    @staticmethod
    def call_sp(conn, sp_name, chunk_size):
        try:
            cursor = conn.cursor()
            cursor.callproc(sp_name)
            return Access.get_cursor_results(cursor, chunk_size)
        except Error as e:
            print(e)
        finally:
            cursor.close()
    @staticmethod
    def call_sp_with_args(conn, sp_name, chunk_size, args):
        try:
            cursor = conn.cursor()
            result_args = cursor.callproc(sp_name, args)
            return result_args, Access.get_cursor_results(cursor, chunk_size)
        except Error as e:
            print(e)
            raise
        finally:
            cursor.close()
    @staticmethod
    def iter_row_many(cursor, size=10):
        while True:
            rows = cursor.fetchmany(size)
            if not rows:
                break
            for row in rows:
                yield row
        cursor.close()
    @staticmethod
    def iter_row_one(cursor):
        row = cursor.fetchone()
        while row is not None:
            yield row
            row = cursor.fetchone()
        cursor.close()
    @staticmethod
    def get_cursor_results(cursor, chunk_size):
        results = []
        for result in cursor.stored_results():
            try:
                desc = result.description
                if chunk_size == 0:
                    results.append((desc, result.fetchall()))
                elif chunk_size == 1:
                    results.append((desc, Access.iter_row_one(result)))
                else:
                    results.append((desc, Access.iter_row_many(result, chunk_size)))
            except Error as e:
                print(e)
                raise
            finally:
                if chunk_size==0:
                    result.close()
        return results
    @staticmethod
    def iter_json(desc, iterator):
        field_count = len(desc)
        field_names = [i[0] for i in desc]
        for row in iterator:
            new_row = {}
            for i in range(field_count):
                new_row[field_names[i]] = row[i]
            yield new_row
    @staticmethod
    def iter_object(columns, iterator):
        for row in iterator:
            yield ObjectDict.ObjectDict(columns, row)


